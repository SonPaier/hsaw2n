/// <reference lib="webworker" />
import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import { registerRoute, NavigationRoute } from 'workbox-routing';
import { NetworkFirst, StaleWhileRevalidate } from 'workbox-strategies';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';
import { ExpirationPlugin } from 'workbox-expiration';

declare const self: ServiceWorkerGlobalScope;

// Clean up old caches from previous versions
cleanupOutdatedCaches();

// Precache all assets generated by the build (with revision hashes)
precacheAndRoute(self.__WB_MANIFEST);

// Use Network First for navigation (HTML pages) - always get fresh content
const navigationHandler = new NetworkFirst({
  cacheName: 'navigation-cache',
  networkTimeoutSeconds: 3,
  plugins: [
    new CacheableResponsePlugin({
      statuses: [0, 200],
    }),
  ],
});

registerRoute(new NavigationRoute(navigationHandler));

// Use Network First for Supabase API calls - always get fresh data to prevent stale cache issues
registerRoute(
  ({ url }) => url.origin.includes('supabase'),
  new NetworkFirst({
    cacheName: 'supabase-api-cache',
    networkTimeoutSeconds: 10,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 5 * 60, // 5 minutes
      }),
    ],
  })
);

// Use Stale While Revalidate for other API calls
registerRoute(
  ({ url }) => url.pathname.startsWith('/api') && !url.origin.includes('supabase'),
  new StaleWhileRevalidate({
    cacheName: 'api-cache',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 5 * 60, // 5 minutes
      }),
    ],
  })
);

// Use Stale While Revalidate for static assets (images, fonts)
registerRoute(
  ({ request }) =>
    request.destination === 'image' ||
    request.destination === 'font' ||
    request.destination === 'style',
  new StaleWhileRevalidate({
    cacheName: 'static-assets',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 24 * 60 * 60, // 24 hours
      }),
    ],
  })
);

interface PushNotificationData {
  title?: string;
  body?: string;
  icon?: string;
  url?: string;
  tag?: string;
}

// Push notification handler
self.addEventListener('push', (event) => {
  console.log('[SW] Push event received:', event);
  
  let data: PushNotificationData = {};
  
  if (event.data) {
    try {
      data = event.data.json();
      console.log('[SW] Push data parsed:', data);
    } catch (e) {
      console.log('[SW] Push data as text:', event.data.text());
      data = { body: event.data.text() };
    }
  }
  
  const options: NotificationOptions = {
    body: data.body || 'Nowa aktywność',
    icon: data.icon || '/pwa-192x192.png',
    badge: '/pwa-192x192.png',
    data: { url: data.url || '/admin' },
    tag: data.tag || 'reservation-' + Date.now(),
    requireInteraction: true,
  };

  console.log('[SW] Showing notification:', data.title, options);

  event.waitUntil(
    self.registration.showNotification(data.title || 'Powiadomienie', options)
  );
});

// Notification click handler - open URL with reservationCode
self.addEventListener('notificationclick', (event) => {
  console.log('[SW] Notification clicked:', event);
  
  event.notification.close();
  
  const url = event.notification.data?.url || '/admin';
  console.log('[SW] Opening URL:', url);
  
  event.waitUntil(
    self.clients.matchAll({ type: 'window', includeUncontrolled: true }).then((windowClients) => {
      // Check if there's already a window open
      for (const client of windowClients) {
        if (client.url.includes('/admin') && 'focus' in client) {
          return client.focus().then(() => {
            if ('navigate' in client) {
              return (client as WindowClient).navigate(url);
            }
          });
        }
      }
      // Open new window if no admin window is open
      return self.clients.openWindow(url);
    })
  );
});

// Service worker install event - wait for natural activation
self.addEventListener('install', () => {
  console.log('[SW] Service Worker installing, version:', new Date().toISOString());
  // Don't call skipWaiting() - let new SW wait for natural page reload
});

// Service worker activate event - clean old caches but don't claim clients
self.addEventListener('activate', (event) => {
  console.log('[SW] Service Worker activating');
  event.waitUntil(
    // Only clear old caches - don't call clients.claim()
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames
          .filter((cacheName) => {
            // Keep only our known caches
            return !['navigation-cache', 'api-cache', 'static-assets', 'workbox-precache-v2'].some(
              (keep) => cacheName.includes(keep)
            );
          })
          .map((cacheName) => {
            console.log('[SW] Deleting old cache:', cacheName);
            return caches.delete(cacheName);
          })
      );
    })
    // Don't call clients.claim() - let clients use new SW on next navigation
  );
});

// Message handler for manual updates
self.addEventListener('message', (event) => {
  console.log('[SW] Message received:', event.data);
  
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});
